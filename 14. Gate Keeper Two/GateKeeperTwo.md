## 13. GateKeeperTwo
The GateKeeperTwo contract contains 3 modifiers, used in the enter function. Each one of these modifiers are challenges to unlock the contract.

### Gate One

```javascript
modifier gateOne() {
    require(msg.sender != tx.origin);
    _;
}
```

This simple modifier verify that the sender is not an EOA and is a contract. It means we need to call the enter funtion with a contract call.


### Gate two
```javascript
modifier gateTwo() {
    uint x;
    assembly { x := extcodesize(caller()) }
    require(x == 0);
    _;
}
```

The second gate verify that the sender is a contract as well, but in a different way : it verifies if the sender contains code using assembly as it is not a built-in solidity command. This method is a good one except in one case : if the call is made from the constructor of the contract, extcodesize(caller) will return 0 as the code isn't loaded yet in the contract address !

In other terms, this method can be tricked by calling the function from the constructor of a our exploit contract.



### Gate three


```javascript
modifier gateThree(bytes8 _gateKey) {
    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);
    _;
}
```

The last gate is a simple math problem. Knowing that in solidity, if you go out of bounds with the uint format, it will act like a modulus : `uint64(0) - 1 = 0xffffffffffffffff` in hex. As the symbol ^ means 'XOR', we need to find a key which gives 0xffffffffffffffff when XORed with `uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))` which is the binary inverse of it (msg.sender = our malicious contract address). We can calculate the inverse of bytes in solidity by XORing it with only ones (0xffffffffffffffff). It gives us our key which is : `uint64(bytes8(keccak256(abi.encodePacked(this)))) ^ (uint64(0) - 1)`.

The exploit contract can be found as GateKeeperTwoExploit.sol in this repository.

